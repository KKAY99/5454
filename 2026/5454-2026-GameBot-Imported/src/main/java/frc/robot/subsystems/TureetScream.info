package frc2026.robot.subsystems.shooter.turret;

import static edu.wpi.first.units.Units.Degrees;
import static edu.wpi.first.units.Units.Rotations;
import static edu.wpi.first.units.Units.Volts;

import com.ctre.phoenix6.SignalLogger;
import com.ctre.phoenix6.hardware.CANcoder;
import com.teamscreamrobotics.dashboard.Ligament;
import com.teamscreamrobotics.dashboard.Mechanism;
import com.teamscreamrobotics.data.Length;
import com.teamscreamrobotics.drivers.TalonFXSubsystem;
import com.teamscreamrobotics.gameutil.FieldConstants;
import com.teamscreamrobotics.math.ScreamMath;
import com.teamscreamrobotics.util.AllianceFlipUtil;
import com.teamscreamrobotics.util.Logger;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismRoot2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine;
import frc2026.robot.Robot;
import frc2026.robot.constants.SimConstants;
import java.util.function.Supplier;
import yams.units.EasyCRT;
import yams.units.EasyCRTConfig;

public class Turret extends TalonFXSubsystem {
  private final CANcoder innerEncoder;
  private final CANcoder outerEncoder;
  private final EasyCRT easyCRT;

  private final Ligament turretTwo =
      new Ligament()
          .withStaticLength(Length.fromInches(5.0))
          .withDynamicAngle(() -> Rotation2d.fromDegrees(getAngle().getDegrees()));

  private final Ligament turretOne =
      new Ligament()
          .withStaticLength(Length.fromInches(5.0))
          .withStaticAngle(Rotation2d.fromDegrees(90));

  public final Mechanism turretMech =
      new Mechanism("Turret Mech", turretOne, turretTwo)
          .withStaticPosition(
              new Translation2d(
                  (SimConstants.MECH_WIDTH / 2.0) + Units.inchesToMeters(12.125),
                  Units.inchesToMeters(15)));

  public final Mechanism2d robotTest = new Mechanism2d(1, 1);

  public final MechanismRoot2d robotRoot = robotTest.getRoot(getName(), 0.5, 0.5);

  public final MechanismLigament2d turret = new MechanismLigament2d("turret", 0.4, 0.0);
  private final SysIdRoutine routine;

  /** Creates a new Pivot Subsystem. */
  public Turret(TalonFXSubsystemConfiguration config) {
    super(config);

    innerEncoder = new CANcoder(TurretConstants.CAN_INNER_ID);
    outerEncoder = new CANcoder(TurretConstants.CAN_OUTER_ID);

    EasyCRTConfig easyCRTConfig =
        new EasyCRTConfig(
                () -> Rotations.of(innerEncoder.getAbsolutePosition().getValueAsDouble()),
                () -> Rotations.of(outerEncoder.getAbsolutePosition().getValueAsDouble()))
            .withAbsoluteEncoder1Gearing(
                TurretConstants.GEAR_0_TOOTH_COUNT, TurretConstants.GEAR_1_TOOTH_COUNT)
            .withAbsoluteEncoder2Gearing(
                TurretConstants.GEAR_0_TOOTH_COUNT,
                TurretConstants.GEAR_1_TOOTH_COUNT,
                TurretConstants.GEAR_2_TOOTH_COUNT)
            .withMechanismRange(
                Rotations.of(TurretConstants.MIN_ROT_DEG / 360),
                Rotations.of(TurretConstants.MAX_ROT_DEG / 360))
            .withMatchTolerance(Rotations.of(TurretConstants.CRT_MATCH_TOLERANCE));

    easyCRT = new EasyCRT(easyCRTConfig);

    // Initialize motor controller
    robotRoot.append(turret);

    innerEncoder.getConfigurator().apply(TurretConstants.INNER_CANCODER_CONFIG);
    outerEncoder.getConfigurator().apply(TurretConstants.OUTTER_CODER_CONFIG);

    routine =
        new SysIdRoutine(
            new SysIdRoutine.Config(
                null, // Use default ramp rate (1 V/s)
                Volts.of(7), // Use dynamic voltage of 7 V
                null, // Use default timeout (10 s)
                // Log state with SignalLogger class
                state ->
                    SignalLogger.writeString(
                        "SysIdTurret_State", state.toString())), // Default config is fine for most
            new SysIdRoutine.Mechanism(
                volts -> master.setVoltage(volts.in(Volts)), // Apply voltage to the motor
                null,
                this));

    easyCRT
        .getAngleOptional()
        .ifPresentOrElse(
            angle -> {
              resetPosition(angle.in(Rotations));
              System.out.println(
                  "Turret initialized with CRT angle: "
                      + (angle.in(Rotations) * 360.0)
                      + " degrees");
            },
            () -> {
              System.err.println(
                  "WARNING: CRT failed to resolve turret angle! Status: "
                      + easyCRT.getLastStatus());
              // Fallback to old method if needed
              resetPosition(0.0);
            });
  }

  /** Update simulation and telemetry. */
  @Override
  public void periodic() {
    super.periodic();
    if (Robot.isSimulation()) {
      turret.setAngle(getAngle().getDegrees());

      SmartDashboard.putData("turret mech", robotTest);
    }

    Logger.log(logPrefix + "Motor Angle", getAngle().getDegrees());

    SmartDashboard.putNumber("Turret Velocity", getVelocity());
    easyCRT
        .getAngleOptional()
        .ifPresent(angle -> SmartDashboard.putNumber("Turret Angle", angle.in(Degrees)));
    SmartDashboard.putNumber(
        "Turret Inner Encoder Angle",
        Units.rotationsToDegrees(innerEncoder.getAbsolutePosition().getValueAsDouble()));
    SmartDashboard.putNumber(
        "Turret Outer Encoder Angle",
        Units.rotationsToDegrees(outerEncoder.getAbsolutePosition().getValueAsDouble()));
  }

  // Does the actual check to ensure that angle is within bounds
  // and will not damage any parts of the turret.
  private boolean isWithinLimits(double angle) {
    return angle >= TurretConstants.MIN_ROT_DEG && angle <= TurretConstants.MAX_ROT_DEG;
  }

  private Rotation2d getSafeTargetAngle(Rotation2d requestedAngle) {
    Rotation2d current = getAngle();
    double currentDegrees = current.getDegrees();

    // shortest circular difference
    double delta =
        Units.radiansToDegrees(MathUtil.angleModulus(requestedAngle.minus(current).getRadians()));

    // two possible path
    double pathCW = delta > 0 ? delta - 360 : delta;
    double pathCCW = delta < 0 ? delta + 360 : delta;

    double endCW = currentDegrees + pathCW;
    double endCCW = currentDegrees + pathCCW;

    boolean cwValid = isWithinLimits(endCW);
    boolean ccwValid = isWithinLimits(endCCW);

    double chosenDelta;

    if (cwValid && ccwValid) {
      chosenDelta = Math.abs(pathCW) < Math.abs(pathCCW) ? pathCW : pathCCW;
    } else if (cwValid) {
      chosenDelta = pathCW;
    } else if (ccwValid) {
      chosenDelta = pathCCW;
    } else {
      // No legal path â€” clamp to nearest limit
      return Rotation2d.fromDegrees(
          MathUtil.clamp(
              requestedAngle.getDegrees(),
              TurretConstants.MIN_ROT_DEG,
              TurretConstants.MAX_ROT_DEG));
    }

    return Rotation2d.fromDegrees(
        MathUtil.clamp(
            chosenDelta + currentDegrees,
            TurretConstants.MIN_ROT_DEG,
            TurretConstants.MAX_ROT_DEG));
  }

  /**
   * Creates a command to move the pivot to a specific angle with a profile.
   *
   * @param angle The target angle in degrees
   * @return A command that moves the pivot to the specified angle
   */
  // This is the robot relative verion of this command.
  public Command moveToAngleCommandRR(Supplier<Rotation2d> angle) {
    return run(
        () -> {
          Rotation2d safeTarget = getSafeTargetAngle(angle.get());
          setSetpointPosition(safeTarget.getRotations());
        });
  }

  /**
   * Creates a command to move the pivot to a specific angle with a profile.
   *
   * @param angle The target angle in degrees
   * @return A command that moves the pivot to the specified angle
   */
  // This is the robot relative verion of this command.
  public Command moveToAngleCommandRR(Rotation2d angle) {
    return moveToAngleCommandRR(() -> angle);
  }

  /**
   * Creates a command to move the turret to a specific angle field relitive.
   *
   * @param angle The target angle in degrees
   * @return A command that moves turret to a specific angle field relitive
   */
  public Command moveToAngleCommandFR(
      Supplier<Rotation2d> angle, Supplier<Rotation2d> robotHeading) {
    return moveToAngleCommandRR(() -> (angle.get().minus(robotHeading.get())));
  }

  /**
   * Creates a command to move the turret to a specific angle field relitive.
   *
   * @param angle The target angle in degrees
   * @return A command that moves turret to a specific angle field relitive
   */
  public Command moveToAngleCommandFR(Rotation2d angle, Supplier<Rotation2d> robotHeading) {
    return moveToAngleCommandFR(() -> angle, robotHeading);
  }

  public Command sysIdQuasistatic(SysIdRoutine.Direction direction) {
    return routine.quasistatic(direction);
  }

  public Command sysIdDynamic(SysIdRoutine.Direction direction) {
    return routine.dynamic(direction);
  }

  public Command pointAtFieldPosition(
      Supplier<Translation2d> targetPosition, Supplier<Pose2d> robotPose) {
    return moveToAngleCommandFR(
        () ->
            ScreamMath.calculateAngleToPoint(
                robotPose.get().getTranslation(), targetPosition.get()),
        () -> robotPose.get().getRotation());
  }

  public Command pointAtFieldPosition(Translation2d targetPosition, Supplier<Pose2d> robotPose) {
    return pointAtFieldPosition(() -> targetPosition, robotPose);
  }

  /**
   * Creates a command to point the turret at the hub center. Uses the hub center position from
   * FieldConstants.
   *
   * @return A command that points the turret at the hub center
   */
  public Command pointAtHubCenter(Supplier<Pose2d> robotPose) {
    return pointAtFieldPosition(
            () ->
                AllianceFlipUtil.get(FieldConstants.Hub.hubCenter, FieldConstants.Hub.oppHubCenter),
            robotPose)
        .withName("PointAtHubCenter");
  }

  public Command aimOnTheFlyPosition(
      Supplier<Translation2d> targetPosition,
      Supplier<Pose2d> robotPose,
      Supplier<ChassisSpeeds> robotSpeed) {
    return run(() -> {
          Translation2d robotVelRobotFrame =
              new Translation2d(
                  robotSpeed.get().vxMetersPerSecond, robotSpeed.get().vyMetersPerSecond);

          Translation2d robotVelFieldFrame =
              robotVelRobotFrame.rotateBy(robotPose.get().getRotation());

          Translation2d futurePose =
              robotPose
                  .get()
                  .getTranslation()
                  .plus(robotVelFieldFrame.times(TurretConstants.LATENCY));

          Translation2d targetVc = targetPosition.get().minus(futurePose);
          double distance = targetVc.getNorm();

          double idealHorizontalSpeed = 1.0;

          Rotation2d turretAngle;

          double translationalSpeed = robotVelFieldFrame.getNorm();
          if (translationalSpeed < 0.05) {
            turretAngle = targetVc.getAngle();
          } else {

            Translation2d shotVec =
                targetVc.div(distance).times(idealHorizontalSpeed).minus(robotVelFieldFrame);
            turretAngle = shotVec.getAngle();
          }

          Rotation2d robotRelativeAngle = turretAngle.minus(robotPose.get().getRotation());

          Rotation2d safeTarget =
              getSafeTargetAngle(
                  robotRelativeAngle
                      .times(TurretConstants.MAGNITUDE)
                      .minus(
                          (Rotation2d.fromRadians(robotSpeed.get().omegaRadiansPerSecond)
                              .times(0.15))));
          setSetpointPosition(safeTarget.getRotations());
        })
        .withName("AimOnTheFly");
  }
}